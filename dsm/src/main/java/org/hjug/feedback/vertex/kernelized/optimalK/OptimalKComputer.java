package org.hjug.feedback.vertex.kernelized.optimalK;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import org.jgrapht.Graph;
import org.jgrapht.alg.cycle.CycleDetector;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.traverse.TopologicalOrderIterator;

/**
 * Computes the optimal k parameter for Directed Feedback Vertex Set (DFVS).
 * This is the minimum number of vertices that need to be removed to make the graph acyclic.
 *
 * Based on algorithms from:
 * - Chen et al. "A Fixed-Parameter Algorithm for the Directed Feedback Vertex Set Problem" (2008)
 * - The paper "Wannabe Bounded Treewidth Graphs Admit a Polynomial Kernel for DFVS" (2025)
 * Generated by Perplexity.ai's Research model
 *
 * Don't use since lower bound is # of SCCs
 * Not used by the kernelized version of the algorithm
 */
public class OptimalKComputer<V, E> {

    private final ExecutorService executorService;
    private final int timeoutSeconds;
    private final boolean useParallelization;

    public OptimalKComputer() {
        this.executorService = ForkJoinPool.commonPool();
        this.timeoutSeconds = 300; // 5 minutes default timeout
        this.useParallelization = true;
    }

    public OptimalKComputer(int timeoutSeconds, boolean useParallelization) {
        this.executorService = useParallelization ? ForkJoinPool.commonPool() : Executors.newSingleThreadExecutor();
        this.timeoutSeconds = timeoutSeconds;
        this.useParallelization = useParallelization;
    }

    /**
     * Computes the optimal k (minimum feedback vertex set size) for the given graph.
     * Uses multiple algorithms and returns the best result found within time limit.
     */
    public OptimalKResult<V> computeOptimalK(Graph<V, E> graph) {
        if (isAcyclic(graph)) {
            return new OptimalKResult<>(0, new HashSet<>(), "Graph is already acyclic", 0);
        }

        long startTime = System.currentTimeMillis();

        // Try multiple approaches in parallel and return the best result
        List<Callable<OptimalKResult<V>>> algorithms = Arrays.asList(
                () -> greedyFeedbackVertexSet(graph, startTime),
                () -> degreeBasedHeuristic(graph, startTime),
                () -> stronglyConnectedComponentsApproach(graph, startTime),
                () -> iterativeRemovalAlgorithm(graph, startTime),
                () -> approximationWithBinarySearch(graph, startTime));

        if (useParallelization) {
            return runAlgorithmsInParallel(algorithms, startTime);
        } else {
            return runAlgorithmsSequentially(algorithms, startTime);
        }
    }

    /**
     * Computes lower and upper bounds for the optimal k
     */
    public KBounds computeKBounds(Graph<V, E> graph) {
        if (isAcyclic(graph)) {
            return new KBounds(0, 0);
        }

        // Lower bound: based on the minimum number of vertices to break all cycles
        int lowerBound = computeLowerBound(graph);

        // Upper bound: simple approximation (worst case is n-1 for a complete graph)
        int upperBound = Math.min(graph.vertexSet().size() - 1, computeUpperBoundApproximation(graph));

        return new KBounds(lowerBound, upperBound);
    }

    /**
     * Greedy algorithm based on vertex degrees and cycle participation
     */
    private OptimalKResult<V> greedyFeedbackVertexSet(Graph<V, E> graph, long startTime) {
        Graph<V, E> workingGraph = copyGraph(graph);
        Set<V> feedbackSet = new HashSet<>();

        while (!isAcyclic(workingGraph) && !isTimeout(startTime)) {
            V bestVertex = selectBestVertexGreedy(workingGraph);
            if (bestVertex == null) break;

            feedbackSet.add(bestVertex);
            workingGraph.removeVertex(bestVertex);
        }

        return new OptimalKResult<>(
                feedbackSet.size(), feedbackSet, "Greedy algorithm", System.currentTimeMillis() - startTime);
    }

    /**
     * Degree-based heuristic - removes vertices with highest total degree first
     */
    private OptimalKResult<V> degreeBasedHeuristic(Graph<V, E> graph, long startTime) {
        Graph<V, E> workingGraph = copyGraph(graph);
        Set<V> feedbackSet = new HashSet<>();

        while (!isAcyclic(workingGraph) && !isTimeout(startTime)) {
            V highestDegreeVertex = workingGraph.vertexSet().stream()
                    .max(Comparator.comparingInt(v -> workingGraph.inDegreeOf(v) + workingGraph.outDegreeOf(v)))
                    .orElse(null);

            if (highestDegreeVertex == null) break;

            feedbackSet.add(highestDegreeVertex);
            workingGraph.removeVertex(highestDegreeVertex);
        }

        return new OptimalKResult<>(
                feedbackSet.size(), feedbackSet, "Degree-based heuristic", System.currentTimeMillis() - startTime);
    }

    /**
     * Strongly Connected Components approach - removes vertices to break SCCs
     */
    private OptimalKResult<V> stronglyConnectedComponentsApproach(Graph<V, E> graph, long startTime) {
        Graph<V, E> workingGraph = copyGraph(graph);
        Set<V> feedbackSet = new HashSet<>();

        while (!isAcyclic(workingGraph) && !isTimeout(startTime)) {
            // Find strongly connected components
            Set<Set<V>> sccs = findStronglyConnectedComponents(workingGraph);

            // Remove one vertex from each non-trivial SCC
            boolean removed = false;
            for (Set<V> scc : sccs) {
                if (scc.size() > 1) {
                    V vertexToRemove = selectBestVertexFromSCC(workingGraph, scc);
                    if (vertexToRemove != null) {
                        feedbackSet.add(vertexToRemove);
                        workingGraph.removeVertex(vertexToRemove);
                        removed = true;
                        break;
                    }
                }
            }

            if (!removed) break;
        }

        return new OptimalKResult<>(
                feedbackSet.size(), feedbackSet, "SCC-based approach", System.currentTimeMillis() - startTime);
    }

    /**
     * Iterative removal algorithm with backtracking
     */
    private OptimalKResult<V> iterativeRemovalAlgorithm(Graph<V, E> graph, long startTime) {
        KBounds bounds = computeKBounds(graph);

        // Try to find solution of increasing sizes from lower bound
        for (int k = bounds.lowerBound; k <= bounds.upperBound && !isTimeout(startTime); k++) {
            Set<V> solution = findFeedbackVertexSetOfSize(graph, k, startTime);
            if (solution != null) {
                return new OptimalKResult<>(
                        k, solution, "Iterative removal with backtracking", System.currentTimeMillis() - startTime);
            }
        }

        // Fallback to greedy if no exact solution found
        return greedyFeedbackVertexSet(graph, startTime);
    }

    /**
     * Approximation algorithm with binary search refinement
     */
    private OptimalKResult<V> approximationWithBinarySearch(Graph<V, E> graph, long startTime) {
        KBounds bounds = computeKBounds(graph);
        int left = bounds.lowerBound;
        int right = bounds.upperBound;
        Set<V> bestSolution = null;

        // Binary search for optimal k
        while (left <= right && !isTimeout(startTime)) {
            int mid = left + (right - left) / 2;
            Set<V> solution = findFeedbackVertexSetOfSize(graph, mid, startTime);

            if (solution != null) {
                bestSolution = solution;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        if (bestSolution != null) {
            return new OptimalKResult<>(
                    bestSolution.size(),
                    bestSolution,
                    "Binary search approximation",
                    System.currentTimeMillis() - startTime);
        }

        // Fallback
        return greedyFeedbackVertexSet(graph, startTime);
    }

    /**
     * Attempts to find a feedback vertex set of exactly the specified size
     */
    private Set<V> findFeedbackVertexSetOfSize(Graph<V, E> graph, int targetSize, long startTime) {
        List<V> vertices = new ArrayList<>(graph.vertexSet());

        // Use iterative deepening with limited combinations due to exponential nature
        if (targetSize > 20 || vertices.size() > 50) {
            // For large problems, use heuristic approach
            return findFeedbackVertexSetHeuristic(graph, targetSize, startTime);
        }

        // Try all combinations of size targetSize (with timeout)
        return findExactFeedbackVertexSet(graph, vertices, targetSize, 0, new HashSet<>(), startTime);
    }

    /**
     * Exact algorithm using backtracking (for small instances)
     */
    private Set<V> findExactFeedbackVertexSet(
            Graph<V, E> graph, List<V> vertices, int remaining, int startIndex, Set<V> currentSet, long startTime) {
        if (isTimeout(startTime)) return null;

        if (remaining == 0) {
            Graph<V, E> testGraph = copyGraph(graph);
            currentSet.forEach(testGraph::removeVertex);
            return isAcyclic(testGraph) ? new HashSet<>(currentSet) : null;
        }

        if (startIndex >= vertices.size() || remaining > vertices.size() - startIndex) {
            return null;
        }

        // Try including current vertex
        V currentVertex = vertices.get(startIndex);
        currentSet.add(currentVertex);
        Set<V> result =
                findExactFeedbackVertexSet(graph, vertices, remaining - 1, startIndex + 1, currentSet, startTime);
        if (result != null) return result;

        // Try excluding current vertex
        currentSet.remove(currentVertex);
        return findExactFeedbackVertexSet(graph, vertices, remaining, startIndex + 1, currentSet, startTime);
    }

    /**
     * Heuristic approach for finding feedback vertex set of target size
     */
    private Set<V> findFeedbackVertexSetHeuristic(Graph<V, E> graph, int targetSize, long startTime) {
        Set<V> solution = new HashSet<>();
        Graph<V, E> workingGraph = copyGraph(graph);

        // Select vertices using multiple criteria
        for (int i = 0; i < targetSize && !workingGraph.vertexSet().isEmpty() && !isTimeout(startTime); i++) {
            V vertex = selectBestVertexMultiCriteria(workingGraph);
            if (vertex == null) break;

            solution.add(vertex);
            workingGraph.removeVertex(vertex);

            if (isAcyclic(workingGraph)) {
                return solution;
            }
        }

        return isAcyclic(workingGraph) ? solution : null;
    }

    /**
     * Selects best vertex using multiple criteria
     */
    private V selectBestVertexMultiCriteria(Graph<V, E> graph) {
        if (graph.vertexSet().isEmpty()) return null;

        return graph.vertexSet().stream()
                .max(Comparator.comparingDouble(v -> computeVertexScore(graph, v)))
                .orElse(null);
    }

    /**
     * Computes score for vertex removal based on multiple factors
     */
    private double computeVertexScore(Graph<V, E> graph, V vertex) {
        int inDegree = graph.inDegreeOf(vertex);
        int outDegree = graph.outDegreeOf(vertex);
        int totalDegree = inDegree + outDegree;

        // Factor in potential cycle breaking
        double cycleBreakingScore = estimateCycleBreaking(graph, vertex);

        // Prefer vertices with high degree and high cycle participation
        return totalDegree + cycleBreakingScore * 2.0;
    }

    /**
     * Estimates how many cycles this vertex participates in
     */
    private double estimateCycleBreaking(Graph<V, E> graph, V vertex) {
        Set<V> inNeighbors =
                graph.incomingEdgesOf(vertex).stream().map(graph::getEdgeSource).collect(Collectors.toSet());

        Set<V> outNeighbors =
                graph.outgoingEdgesOf(vertex).stream().map(graph::getEdgeTarget).collect(Collectors.toSet());

        // Count potential 2-paths that could form cycles through this vertex
        double score = 0;
        for (V in : inNeighbors) {
            for (V out : outNeighbors) {
                if (!in.equals(out) && graph.containsEdge(out, in)) {
                    score += 1.0; // This vertex breaks a 3-cycle
                }
            }
        }

        return score;
    }

    /**
     * Selects best vertex using greedy criteria
     */
    private V selectBestVertexGreedy(Graph<V, E> graph) {
        if (graph.vertexSet().isEmpty()) return null;

        // Prefer vertices that participate in many cycles
        return graph.vertexSet().stream()
                .max(Comparator.comparingDouble(v -> {
                    int degree = graph.inDegreeOf(v) + graph.outDegreeOf(v);
                    double cycleScore = estimateCycleBreaking(graph, v);
                    return degree + cycleScore * 1.5;
                }))
                .orElse(null);
    }

    /**
     * Selects best vertex from a strongly connected component
     */
    private V selectBestVertexFromSCC(Graph<V, E> graph, Set<V> scc) {
        return scc.stream()
                .max(Comparator.comparingInt(v -> graph.inDegreeOf(v) + graph.outDegreeOf(v)))
                .orElse(null);
    }

    /**
     * Computes lower bound for optimal k
     */
    private int computeLowerBound(Graph<V, E> graph) {
        // Simple lower bound: at least one vertex per strongly connected component > 1
        Set<Set<V>> sccs = findStronglyConnectedComponents(graph);
        return (int) sccs.stream().mapToLong(scc -> scc.size() > 1 ? 1 : 0).sum();
    }

    /**
     * Computes upper bound approximation
     */
    private int computeUpperBoundApproximation(Graph<V, E> graph) {
        // Use greedy approximation for upper bound
        Graph<V, E> workingGraph = copyGraph(graph);
        int count = 0;

        while (!isAcyclic(workingGraph) && count < graph.vertexSet().size()) {
            V vertex = selectBestVertexGreedy(workingGraph);
            if (vertex == null) break;

            workingGraph.removeVertex(vertex);
            count++;
        }

        return count;
    }

    /**
     * Finds strongly connected components using Tarjan's algorithm
     */
    private Set<Set<V>> findStronglyConnectedComponents(Graph<V, E> graph) {
        Set<Set<V>> components = new HashSet<>();
        Map<V, Integer> indices = new HashMap<>();
        Map<V, Integer> lowLinks = new HashMap<>();
        Map<V, Boolean> onStack = new HashMap<>();
        Stack<V> stack = new Stack<>();
        AtomicInteger index = new AtomicInteger(0);

        for (V vertex : graph.vertexSet()) {
            if (!indices.containsKey(vertex)) {
                strongConnect(graph, vertex, indices, lowLinks, onStack, stack, index, components);
            }
        }

        return components;
    }

    /**
     * Helper method for Tarjan's algorithm
     */
    private void strongConnect(
            Graph<V, E> graph,
            V vertex,
            Map<V, Integer> indices,
            Map<V, Integer> lowLinks,
            Map<V, Boolean> onStack,
            Stack<V> stack,
            AtomicInteger indexCounter,
            Set<Set<V>> components) {
        int vertexIndex = indexCounter.getAndIncrement();
        indices.put(vertex, vertexIndex);
        lowLinks.put(vertex, vertexIndex);
        stack.push(vertex);
        onStack.put(vertex, true);

        for (E edge : graph.outgoingEdgesOf(vertex)) {
            V successor = graph.getEdgeTarget(edge);

            if (!indices.containsKey(successor)) {
                strongConnect(graph, successor, indices, lowLinks, onStack, stack, indexCounter, components);
                lowLinks.put(vertex, Math.min(lowLinks.get(vertex), lowLinks.get(successor)));
            } else if (onStack.getOrDefault(successor, false)) {
                lowLinks.put(vertex, Math.min(lowLinks.get(vertex), indices.get(successor)));
            }
        }

        if (lowLinks.get(vertex).equals(indices.get(vertex))) {
            Set<V> component = new HashSet<>();
            V w;
            do {
                w = stack.pop();
                onStack.put(w, false);
                component.add(w);
            } while (!w.equals(vertex));

            components.add(component);
        }
    }

    /**
     * Runs algorithms in parallel and returns best result
     */
    private OptimalKResult<V> runAlgorithmsInParallel(List<Callable<OptimalKResult<V>>> algorithms, long startTime) {
        try {
            List<Future<OptimalKResult<V>>> futures =
                    executorService.invokeAll(algorithms, timeoutSeconds, TimeUnit.SECONDS);

            OptimalKResult<V> bestResult = null;

            for (Future<OptimalKResult<V>> future : futures) {
                try {
                    OptimalKResult<V> result = future.get();
                    if (bestResult == null || result.getOptimalK() < bestResult.getOptimalK()) {
                        bestResult = result;
                    }
                } catch (Exception e) {
                    // Continue with other results
                }
            }

            return bestResult != null
                    ? bestResult
                    : new OptimalKResult<>(
                            Integer.MAX_VALUE,
                            new HashSet<>(),
                            "All algorithms failed",
                            System.currentTimeMillis() - startTime);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return new OptimalKResult<>(
                    Integer.MAX_VALUE,
                    new HashSet<>(),
                    "Computation interrupted",
                    System.currentTimeMillis() - startTime);
        }
    }

    /**
     * Runs algorithms sequentially and returns best result
     */
    private OptimalKResult<V> runAlgorithmsSequentially(List<Callable<OptimalKResult<V>>> algorithms, long startTime) {
        OptimalKResult<V> bestResult = null;

        for (Callable<OptimalKResult<V>> algorithm : algorithms) {
            if (isTimeout(startTime)) break;

            try {
                OptimalKResult<V> result = algorithm.call();
                if (bestResult == null || result.getOptimalK() < bestResult.getOptimalK()) {
                    bestResult = result;
                }
            } catch (Exception e) {
                // Continue with next algorithm
            }
        }

        return bestResult != null
                ? bestResult
                : new OptimalKResult<>(
                        Integer.MAX_VALUE,
                        new HashSet<>(),
                        "All algorithms failed",
                        System.currentTimeMillis() - startTime);
    }

    /**
     * Checks if computation has timed out
     */
    private boolean isTimeout(long startTime) {
        return System.currentTimeMillis() - startTime > timeoutSeconds * 1000L;
    }

    /**
     * Checks if graph is acyclic
     */
    private boolean isAcyclic(Graph<V, E> graph) {
        try {
            new CycleDetector<>(graph);
            return !new CycleDetector<>(graph).detectCycles();
        } catch (Exception e) {
            // Fallback: try topological sort
            try {
                TopologicalOrderIterator<V, E> iterator = new TopologicalOrderIterator<>(graph);
                int count = 0;
                while (iterator.hasNext()) {
                    iterator.next();
                    count++;
                }
                return count == graph.vertexSet().size();
            } catch (Exception ex) {
                return false;
            }
        }
    }

    /**
     * Creates a copy of the graph
     */
    @SuppressWarnings("unchecked")
    private Graph<V, E> copyGraph(Graph<V, E> original) {
        Graph<V, E> copy = new DefaultDirectedGraph<>(
                (Class<? extends E>) original.getEdgeSupplier().get().getClass());

        // Add vertices
        for (V vertex : original.vertexSet()) {
            copy.addVertex(vertex);
        }

        // Add edges
        for (E edge : original.edgeSet()) {
            V source = original.getEdgeSource(edge);
            V target = original.getEdgeTarget(edge);
            copy.addEdge(source, target);
        }

        return copy;
    }

    /**
     * Result container for optimal k computation
     */
    public static class OptimalKResult<V> {
        private final int optimalK;
        private final Set<V> feedbackVertexSet;
        private final String algorithmUsed;
        private final long computationTimeMs;

        public OptimalKResult(int optimalK, Set<V> feedbackVertexSet, String algorithmUsed, long computationTimeMs) {
            this.optimalK = optimalK;
            this.feedbackVertexSet = new HashSet<>(feedbackVertexSet);
            this.algorithmUsed = algorithmUsed;
            this.computationTimeMs = computationTimeMs;
        }

        public int getOptimalK() {
            return optimalK;
        }

        public Set<V> getFeedbackVertexSet() {
            return new HashSet<>(feedbackVertexSet);
        }

        public String getAlgorithmUsed() {
            return algorithmUsed;
        }

        public long getComputationTimeMs() {
            return computationTimeMs;
        }

        @Override
        public String toString() {
            return String.format(
                    "OptimalKResult{k=%d, |FVS|=%d, algorithm='%s', time=%dms}",
                    optimalK, feedbackVertexSet.size(), algorithmUsed, computationTimeMs);
        }
    }

    /**
     * Container for k bounds
     */
    public static class KBounds {
        public final int lowerBound;
        public final int upperBound;

        public KBounds(int lowerBound, int upperBound) {
            this.lowerBound = lowerBound;
            this.upperBound = upperBound;
        }

        @Override
        public String toString() {
            return String.format("KBounds[%d, %d]", lowerBound, upperBound);
        }
    }

    public void shutdown() {
        if (executorService != null && !executorService.isShutdown()) {
            executorService.shutdown();
        }
    }
}
