package org.hjug.feedback.vertex.approximate;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.jgrapht.Graph;
import org.jgrapht.alg.connectivity.KosarajuStrongConnectivityInspector;
import org.jgrapht.alg.interfaces.ShortestPathAlgorithm;
import org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm;
import org.jgrapht.alg.shortestpath.DijkstraShortestPath;
import org.jgrapht.graph.AsSubgraph;
import org.jgrapht.graph.AsWeightedGraph;

/**
 * Parallel implementation of the Feedback Vertex Set algorithm
 * Based on "Approximating Minimum Feedback Sets and Multicuts in Directed Graphs"
 * DOI:10.1007/PL00009191
 * https://www.researchgate.net/publication/227278349_Approximating_Minimum_Feedback_Sets_and_Multicuts_in_Directed_Graphs
 * Generated by Perplexity.ai's Research model
 */
public class FeedbackVertexSetSolver<V, E> {

    private final Graph<V, E> graph;
    private final Set<V> specialVertices;
    private final Map<V, Double> vertexWeights;
    private final Map<V, Double> fractionalSolution;
    private final double epsilon;
    private final ForkJoinPool forkJoinPool;

    public FeedbackVertexSetSolver(
            Graph<V, E> graph, Set<V> specialVertices, Map<V, Double> vertexWeights, double epsilon) {
        this.graph = graph;
        this.specialVertices = specialVertices != null ? specialVertices : new HashSet<>(graph.vertexSet());
        this.vertexWeights = vertexWeights != null ? vertexWeights : createUniformWeights();
        this.epsilon = epsilon;
        this.forkJoinPool = ForkJoinPool.commonPool();
        this.fractionalSolution = computeFractionalSolution();
    }

    /**
     * Creates uniform weights for all vertices when no weights are provided[3]
     */
    private Map<V, Double> createUniformWeights() {
        Map<V, Double> weights = new ConcurrentHashMap<>();
        graph.vertexSet().parallelStream().forEach(v -> weights.put(v, 1.0));
        return weights;
    }

    /**
     * Computes the fractional solution using the combinatorial algorithm from the paper[1]
     */
    private Map<V, Double> computeFractionalSolution() {
        Map<V, Double> y = new ConcurrentHashMap<>();
        graph.vertexSet().parallelStream().forEach(v -> y.put(v, 0.0));

        AtomicInteger iteration = new AtomicInteger(0);

        while (hasInterestingCycle()) {
            // Compute cycle counts for each vertex in parallel[9]
            Map<V, Long> cycleCounts = computeCycleCounts();

            // Find vertex minimizing w(v)/f(v) using parallel streams[10]
            Optional<V> minVertex = graph.vertexSet().parallelStream()
                    .filter(v -> cycleCounts.getOrDefault(v, 0L) > 0)
                    .min(Comparator.comparingDouble(v -> vertexWeights.get(v) / cycleCounts.get(v)));

            if (!minVertex.isPresent()) break;

            V vertex = minVertex.get();
            double increment = vertexWeights.get(vertex) / cycleCounts.get(vertex);

            // Update fractional solution atomically
            y.compute(vertex, (k, val) -> Math.min(1.0, val + increment * (1 + epsilon)));

            iteration.incrementAndGet();
            if (iteration.get() > graph.vertexSet().size() * 10) break; // Safety check
        }

        return y;
    }

    /**
     * Computes cycle counts for vertices using strongly connected components[9][12]
     */
    private Map<V, Long> computeCycleCounts() {
        Map<V, Long> counts = new ConcurrentHashMap<>();

        StrongConnectivityAlgorithm<V, E> scAlg = new KosarajuStrongConnectivityInspector<>(graph);

        scAlg.stronglyConnectedSets().parallelStream()
                .filter(this::isInterestingComponent)
                .forEach(scc -> {
                    scc.parallelStream().forEach(v -> counts.merge(v, 1L, Long::sum));
                });

        return counts;
    }

    /**
     * Checks if a strongly connected component contains special vertices and forms cycles[1]
     */
    private boolean isInterestingComponent(Set<V> scc) {
        boolean containsSpecial = scc.stream().anyMatch(specialVertices::contains);
        boolean hasCycle = scc.size() > 1
                || (scc.size() == 1
                        && graph.containsEdge(
                                scc.iterator().next(), scc.iterator().next()));
        return containsSpecial && hasCycle;
    }

    /**
     * Checks if the graph contains interesting cycles[1]
     */
    private boolean hasInterestingCycle() {
        StrongConnectivityAlgorithm<V, E> scAlg = new KosarajuStrongConnectivityInspector<>(graph);

        return scAlg.stronglyConnectedSets().parallelStream().anyMatch(this::isInterestingComponent);
    }

    /**
     * Main solving method implementing the recursive decomposition algorithm[1]
     */
    public FeedbackVertexSetResult<V> solve() {
        return solveRecursive(graph, specialVertices);
    }

    /**
     * Recursive solver using graph decomposition and parallel processing[1][25]
     */
    private FeedbackVertexSetResult<V> solveRecursive(Graph<V, E> currentGraph, Set<V> currentSpecial) {
        if (!hasInterestingCycleInSubgraph(currentGraph, currentSpecial)) {
            return new FeedbackVertexSetResult<>(new HashSet<>());
        }

        // Select source vertex from special vertices
        V source = currentSpecial.iterator().next();

        // Compute distances using transformed edge weights[20][21]
        Map<V, Double> distances = computeDistances(currentGraph, source);

        // Find all distinct distance values
        List<Double> distValues =
                distances.values().parallelStream().distinct().sorted().collect(Collectors.toList());

        // Evaluate cut candidates in parallel[10]
        List<CutCandidate<V>> candidates = distValues.parallelStream()
                .map(dist -> evaluateCut(currentGraph, distances, dist))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        if (candidates.isEmpty()) {
            // Fallback: select vertex with maximum degree
            Optional<V> maxDegreeVertex = currentGraph.vertexSet().parallelStream()
                    .max(Comparator.comparingInt(v -> currentGraph.inDegreeOf(v) + currentGraph.outDegreeOf(v)));

            if (maxDegreeVertex.isPresent()) {
                Set<V> solution = new HashSet<>();
                solution.add(maxDegreeVertex.get());
                return new FeedbackVertexSetResult<>(solution);
            }
            return new FeedbackVertexSetResult<>(new HashSet<>());
        }

        // Select best cut candidate
        CutCandidate<V> bestCandidate = candidates.parallelStream()
                .min(Comparator.comparingDouble(c -> c.ratio))
                .orElseThrow();

        // Create subgraphs using AsSubgraph[24]
        Set<V> leftVertices = createLeftPartition(currentGraph, distances, bestCandidate.distance);
        Set<V> rightVertices = createRightPartition(currentGraph, distances, bestCandidate.distance);

        // Recursive solve using ForkJoinPool[25]
        CompletableFuture<FeedbackVertexSetResult<V>> leftFuture = CompletableFuture.supplyAsync(
                () -> {
                    if (!leftVertices.isEmpty()) {
                        Graph<V, E> leftGraph = new AsSubgraph<>(currentGraph, leftVertices);
                        Set<V> leftSpecial = intersection(currentSpecial, leftVertices);
                        return solveRecursive(leftGraph, leftSpecial);
                    }
                    return new FeedbackVertexSetResult<>(new HashSet<>());
                },
                forkJoinPool);

        CompletableFuture<FeedbackVertexSetResult<V>> rightFuture = CompletableFuture.supplyAsync(
                () -> {
                    if (!rightVertices.isEmpty()) {
                        Graph<V, E> rightGraph = new AsSubgraph<>(currentGraph, rightVertices);
                        Set<V> rightSpecial = intersection(currentSpecial, rightVertices);
                        return solveRecursive(rightGraph, rightSpecial);
                    }
                    return new FeedbackVertexSetResult<>(new HashSet<>());
                },
                forkJoinPool);

        // Combine results
        try {
            FeedbackVertexSetResult<V> leftResult = leftFuture.get();
            FeedbackVertexSetResult<V> rightResult = rightFuture.get();

            Set<V> solution = new HashSet<>(bestCandidate.cut);
            solution.addAll(leftResult.getFeedbackVertices());
            solution.addAll(rightResult.getFeedbackVertices());

            return new FeedbackVertexSetResult<>(solution);
        } catch (InterruptedException | ExecutionException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Parallel execution failed", e);
        }
    }

    /**
     * Computes shortest path distances using Dijkstra algorithm with transformed weights[20][26]
     */
    private Map<V, Double> computeDistances(Graph<V, E> graph, V source) {
        // Transform to weighted graph using fractional solution values[26]
        Function<E, Double> weightFunction = edge -> {
            V target = graph.getEdgeTarget(edge);
            return fractionalSolution.getOrDefault(target, 0.0);
        };

        AsWeightedGraph<V, E> weightedGraph = new AsWeightedGraph<>(graph, weightFunction, false, false);

        // Compute shortest paths using Dijkstra[20]
        DijkstraShortestPath<V, E> dijkstra = new DijkstraShortestPath<>(weightedGraph);
        ShortestPathAlgorithm.SingleSourcePaths<V, E> paths = dijkstra.getPaths(source);

        Map<V, Double> distances = new ConcurrentHashMap<>();
        graph.vertexSet().parallelStream().forEach(v -> {
            double distance = paths.getWeight(v);
            if (Double.isInfinite(distance)) {
                distance = Double.MAX_VALUE;
            }
            distances.put(v, distance + fractionalSolution.getOrDefault(source, 0.0));
        });

        return distances;
    }

    /**
     * Evaluates a cut candidate based on the ratio of actual weight to fractional weight[1]
     */
    private CutCandidate<V> evaluateCut(Graph<V, E> graph, Map<V, Double> distances, double cutDistance) {
        Set<V> cut = graph.vertexSet().parallelStream()
                .filter(v -> Math.abs(distances.get(v) - cutDistance) < 1e-10)
                .collect(Collectors.toSet());

        if (cut.isEmpty()) return null;

        double actualWeight = cut.parallelStream()
                .mapToDouble(v -> vertexWeights.getOrDefault(v, 1.0))
                .sum();

        double fractionalWeight = cut.parallelStream()
                .mapToDouble(v -> fractionalSolution.getOrDefault(v, 0.0))
                .sum();

        if (fractionalWeight <= 1e-10) return null;

        return new CutCandidate<>(cut, actualWeight / fractionalWeight, cutDistance);
    }

    /**
     * Creates left partition of vertices[1]
     */
    private Set<V> createLeftPartition(Graph<V, E> graph, Map<V, Double> distances, double cutDistance) {
        return graph.vertexSet().parallelStream()
                .filter(v -> distances.get(v) < cutDistance - 1e-10)
                .collect(Collectors.toSet());
    }

    /**
     * Creates right partition of vertices[1]
     */
    private Set<V> createRightPartition(Graph<V, E> graph, Map<V, Double> distances, double cutDistance) {
        return graph.vertexSet().parallelStream()
                .filter(v -> distances.get(v) > cutDistance + 1e-10)
                .collect(Collectors.toSet());
    }

    /**
     * Checks for interesting cycles in a subgraph[9]
     */
    private boolean hasInterestingCycleInSubgraph(Graph<V, E> subgraph, Set<V> special) {
        if (subgraph.vertexSet().isEmpty()) return false;

        StrongConnectivityAlgorithm<V, E> scAlg = new KosarajuStrongConnectivityInspector<>(subgraph);

        return scAlg.stronglyConnectedSets().parallelStream().anyMatch(scc -> {
            boolean containsSpecial = scc.stream().anyMatch(special::contains);
            boolean hasCycle = scc.size() > 1
                    || (scc.size() == 1
                            && subgraph.containsEdge(
                                    scc.iterator().next(), scc.iterator().next()));
            return containsSpecial && hasCycle;
        });
    }

    /**
     * Computes intersection of two sets using parallel streams[10]
     */
    private Set<V> intersection(Set<V> set1, Set<V> set2) {
        return set1.parallelStream().filter(set2::contains).collect(Collectors.toSet());
    }

    /**
     * Cut candidate data structure[1]
     */
    private static class CutCandidate<V> {
        final Set<V> cut;
        final double ratio;
        final double distance;

        CutCandidate(Set<V> cut, double ratio, double distance) {
            this.cut = cut;
            this.ratio = ratio;
            this.distance = distance;
        }
    }
}
