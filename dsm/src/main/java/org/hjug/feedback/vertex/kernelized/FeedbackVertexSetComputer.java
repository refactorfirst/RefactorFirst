package org.hjug.feedback.vertex.kernelized;

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import org.hjug.feedback.SuperTypeToken;
import org.jgrapht.Graph;
import org.jgrapht.alg.connectivity.KosarajuStrongConnectivityInspector;
import org.jgrapht.alg.cycle.CycleDetector;
import org.jgrapht.graph.DefaultDirectedGraph;

/**
 * Multithreaded feedback vertex set computer implementing multiple algorithms
 * for approximating minimum directed feedback vertex sets.
 * Generated by Perplexity.ai's Research model
 */
public class FeedbackVertexSetComputer<V, E> {

    private final Class<E> edgeClass;
    private final ExecutorService executorService;
    private final Map<Graph<V, E>, Set<V>> greedyFeedbackVertexSetCache;

    public FeedbackVertexSetComputer(SuperTypeToken<E> edgeTypeToken) {
        this.edgeClass = edgeTypeToken.getClassFromTypeToken();
        this.executorService = ForkJoinPool.commonPool();
        this.greedyFeedbackVertexSetCache = new ConcurrentHashMap<>();
    }

    public FeedbackVertexSetComputer(SuperTypeToken<E> edgeTypeToken, int parallelismLevel) {
        this.edgeClass = edgeTypeToken.getClassFromTypeToken();
        this.executorService = Executors.newWorkStealingPool(parallelismLevel);
        this.greedyFeedbackVertexSetCache = new ConcurrentHashMap<>();
    }

    /**
     * Computes k: the size of minimum directed feedback vertex set
     */
    public int computeK(Graph<V, E> graph) {
        if (!hasCycles(graph)) {
            return 0;
        }

        // Run multiple approximation algorithms in parallel
        List<Callable<Set<V>>> algorithms = Arrays.asList(
                () -> greedyFeedbackVertexSet(graph),
                () -> stronglyConnectedComponentsBasedFVS(graph),
                () -> degreeBasedFeedbackVertexSet(graph),
                () -> localSearchFeedbackVertexSet(graph));

        try {
            List<Future<Set<V>>> results = executorService.invokeAll(algorithms, 60, TimeUnit.SECONDS);

            return results.parallelStream()
                    .map(this::getFutureValue)
                    .filter(Objects::nonNull)
                    .filter(fvs -> isValidFeedbackVertexSet(graph, fvs))
                    .mapToInt(Set::size)
                    .min()
                    .orElse(computeFallbackK(graph));

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return computeFallbackK(graph);
        }
    }

    /**
     * Greedy feedback vertex set algorithm
     */
    Set<V> greedyFeedbackVertexSet(Graph<V, E> graph) {
        return greedyFeedbackVertexSetCache.computeIfAbsent(graph, g -> {
            Set<V> feedbackSet = ConcurrentHashMap.newKeySet();
            Graph<V, E> workingGraph = copyGraph(g);

            while (hasCycles(workingGraph)) {
                // Find vertex with maximum degree in current SCCs
                V maxDegreeVertex = findVertexInCyclesWithMaxDegree(workingGraph);

                if (maxDegreeVertex == null) break;

                feedbackSet.add(maxDegreeVertex);
                workingGraph.removeVertex(maxDegreeVertex);
            }

            return feedbackSet;
        });
    }

    /**
     * SCC-based feedback vertex set algorithm
     */
    private Set<V> stronglyConnectedComponentsBasedFVS(Graph<V, E> graph) {
        Set<V> feedbackSet = ConcurrentHashMap.newKeySet();
        Graph<V, E> workingGraph = copyGraph(graph);

        while (hasCycles(workingGraph)) {
            KosarajuStrongConnectivityInspector<V, E> inspector =
                    new KosarajuStrongConnectivityInspector<>(workingGraph);

            List<Set<V>> sccs = inspector.stronglyConnectedSets();

            // Process non-trivial SCCs in parallel
            Optional<V> vertexToRemove = sccs.parallelStream()
                    .filter(scc -> scc.size() > 1)
                    .flatMap(Collection::stream)
                    .max(Comparator.comparingInt(v -> workingGraph.inDegreeOf(v) + workingGraph.outDegreeOf(v)));

            if (vertexToRemove.isPresent()) {
                V vertex = vertexToRemove.get();
                feedbackSet.add(vertex);
                workingGraph.removeVertex(vertex);
            } else {
                break;
            }
        }

        return feedbackSet;
    }

    /**
     * Degree-based feedback vertex set algorithm
     */
    private Set<V> degreeBasedFeedbackVertexSet(Graph<V, E> graph) {
        Set<V> feedbackSet = ConcurrentHashMap.newKeySet();
        Graph<V, E> workingGraph = copyGraph(graph);

        while (hasCycles(workingGraph)) {
            // Calculate degree scores in parallel
            Map<V, Double> degreeScores = workingGraph.vertexSet().parallelStream()
                    .collect(Collectors.toConcurrentMap(v -> v, v -> calculateDegreeScore(workingGraph, v)));

            Optional<V> bestVertex = degreeScores.entrySet().parallelStream()
                    .filter(entry -> entry.getValue() > 0)
                    .max(Map.Entry.comparingByValue())
                    .map(Map.Entry::getKey);

            if (bestVertex.isPresent()) {
                V vertex = bestVertex.get();
                feedbackSet.add(vertex);
                workingGraph.removeVertex(vertex);
            } else {
                break;
            }
        }

        return feedbackSet;
    }

    /**
     * Local search improvement for feedback vertex set
     */
    private Set<V> localSearchFeedbackVertexSet(Graph<V, E> graph) {
        Set<V> currentSolution = greedyFeedbackVertexSet(graph);
        boolean improved = true;
        int maxIterations = 100;
        int iteration = 0;

        while (improved && iteration < maxIterations) {
            improved = false;
            iteration++;

            // Try to improve by removing and adding vertices
            for (V vertex : new HashSet<>(currentSolution)) {
                Set<V> candidateSolution = new HashSet<>(currentSolution);
                candidateSolution.remove(vertex);

                if (isValidFeedbackVertexSet(graph, candidateSolution)) {
                    currentSolution = candidateSolution;
                    improved = true;
                    break;
                }

                // Try swapping with non-solution vertices
                for (V replacement : graph.vertexSet()) {
                    if (!currentSolution.contains(replacement)) {
                        Set<V> swapSolution = new HashSet<>(currentSolution);
                        swapSolution.remove(vertex);
                        swapSolution.add(replacement);

                        if (isValidFeedbackVertexSet(graph, swapSolution)
                                && swapSolution.size() < currentSolution.size()) {
                            currentSolution = swapSolution;
                            improved = true;
                            break;
                        }
                    }
                }

                if (improved) break;
            }
        }

        return currentSolution;
    }

    /**
     * Finds vertex in cycles with maximum degree
     */
    private V findVertexInCyclesWithMaxDegree(Graph<V, E> graph) {
        KosarajuStrongConnectivityInspector<V, E> inspector = new KosarajuStrongConnectivityInspector<>(graph);

        return inspector.stronglyConnectedSets().parallelStream()
                .filter(scc ->
                        scc.size() > 1 || hasSelfLoop(graph, scc.iterator().next()))
                .flatMap(Collection::stream)
                .max(Comparator.comparingInt(v -> graph.inDegreeOf(v) + graph.outDegreeOf(v)))
                .orElse(null);
    }

    /**
     * Calculates degree-based score for vertex selection
     */
    private double calculateDegreeScore(Graph<V, E> graph, V vertex) {
        int inDegree = graph.inDegreeOf(vertex);
        int outDegree = graph.outDegreeOf(vertex);

        // Check if vertex is in any SCC with size > 1
        KosarajuStrongConnectivityInspector<V, E> inspector = new KosarajuStrongConnectivityInspector<>(graph);

        boolean inNonTrivialSCC =
                inspector.stronglyConnectedSets().stream().anyMatch(scc -> scc.size() > 1 && scc.contains(vertex));

        if (!inNonTrivialSCC && !hasSelfLoop(graph, vertex)) {
            return 0.0; // Not in any cycle
        }

        return (inDegree + outDegree) + (inDegree * outDegree * 0.5) + (hasSelfLoop(graph, vertex) ? 1.0 : 0.0);
    }

    /**
     * Checks if a vertex has a self-loop
     */
    private boolean hasSelfLoop(Graph<V, E> graph, V vertex) {
        return graph.containsEdge(vertex, vertex);
    }

    /**
     * Checks if the graph has cycles
     */
    private boolean hasCycles(Graph<V, E> graph) {
        CycleDetector<V, E> detector = new CycleDetector<>(graph);
        return detector.detectCycles();
    }

    /**
     * Validates if a set is a feedback vertex set
     */
    private boolean isValidFeedbackVertexSet(Graph<V, E> graph, Set<V> feedbackSet) {
        Graph<V, E> testGraph = copyGraph(graph);

        feedbackSet.forEach(testGraph::removeVertex);

        return !hasCycles(testGraph);
    }

    /**
     * Creates a copy of the graph
     */
    @SuppressWarnings("unchecked")
    private Graph<V, E> copyGraph(Graph<V, E> original) {
        // TODO: consider using SparseIntDirectedGraph to improve copy performance
        Graph<V, E> copy = new DefaultDirectedGraph<>(edgeClass);

        // Add vertices
        original.vertexSet().forEach(copy::addVertex);

        // Add edges
        original.edgeSet().forEach(edge -> {
            V source = original.getEdgeSource(edge);
            V target = original.getEdgeTarget(edge);
            // adding a large number of edges takes time
            copy.addEdge(source, target);
        });

        return copy;
    }

    /**
     * Fallback computation for k
     */
    private int computeFallbackK(Graph<V, E> graph) {
        // Simple fallback: count self-loops + rough estimate
        long selfLoops = graph.vertexSet().parallelStream()
                .filter(v -> graph.containsEdge(v, v))
                .count();

        KosarajuStrongConnectivityInspector<V, E> inspector = new KosarajuStrongConnectivityInspector<>(graph);

        long nonTrivialSCCs = inspector.stronglyConnectedSets().parallelStream()
                .filter(scc -> scc.size() > 1)
                .count();

        return (int) Math.max(1, selfLoops + Math.max(1, nonTrivialSCCs / 2));
    }

    private Set<V> getFutureValue(Future<Set<V>> future) {
        try {
            return future.get();
        } catch (Exception e) {
            return null;
        }
    }

    public void shutdown() {
        if (executorService != null && !executorService.isShutdown()) {
            executorService.shutdown();
        }
    }
}
