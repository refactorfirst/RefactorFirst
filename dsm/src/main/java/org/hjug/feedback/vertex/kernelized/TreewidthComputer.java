package org.hjug.feedback.vertex.kernelized;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import org.jgrapht.Graph;
import org.jgrapht.Graphs;
import org.jgrapht.alg.cycle.CycleDetector;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.graph.DefaultUndirectedGraph;

/**
 * Multithreaded treewidth computer that implements multiple heuristic algorithms
 * for approximating treewidth of graphs after modulator removal.
 * Generated by Perplexity.ai's Research model
 */
public class TreewidthComputer<V, E> {

    private final ExecutorService executorService;

    public TreewidthComputer() {
        this.executorService = ForkJoinPool.commonPool();
    }

    public TreewidthComputer(int parallelismLevel) {
        this.executorService = Executors.newWorkStealingPool(parallelismLevel);
    }

    /**
     * Computes eta (Î·): the treewidth of the undirected version of the graph
     * after removing the modulator vertices.
     */
    public int computeEta(Graph<V, E> graph, Set<V> modulator) {
        // Convert to undirected graph and remove modulator
        Graph<V, DefaultEdge> undirectedGraph = convertToUndirectedWithoutModulator(graph, modulator);

        // shortcuts
        if (undirectedGraph.vertexSet().isEmpty() || undirectedGraph.vertexSet().size() == 1) {
            return 0;
        } else if (!hasCycles(graph)) {
            // A graph without cycles will have an eta of 1 for our purposes
            // since a graph that does not have cycles is not of interest
            return 1;
        }

        // Run multiple treewidth approximation algorithms in parallel
        List<Callable<Integer>> algorithms = Arrays.asList(
                () -> minDegreeEliminationTreewidth(undirectedGraph),
                () -> fillInHeuristicTreewidth(undirectedGraph),
                () -> maxCliqueTreewidth(undirectedGraph),
                () -> greedyTriangulationTreewidth(undirectedGraph));

        try {
            List<Future<Integer>> results = executorService.invokeAll(algorithms, 30, TimeUnit.SECONDS);

            return results.parallelStream()
                    .map(this::getFutureValue)
                    .filter(Objects::nonNull)
                    .filter(eta -> eta > 1) // if a graph has a cycle, eta will be more than 1
                    .min(Integer::compareTo)
                    .orElse(undirectedGraph.vertexSet().size() - 1); // Worst case bound

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return computeFallbackTreewidth(undirectedGraph);
        }
    }

    /**
     * Checks if the graph has cycles
     */
    private boolean hasCycles(Graph<V, E> graph) {
        CycleDetector<V, E> detector = new CycleDetector<>(graph);
        return detector.detectCycles();
    }

    /**
     * Converts directed/undirected graph to undirected and removes modulator vertices
     */
    private Graph<V, DefaultEdge> convertToUndirectedWithoutModulator(Graph<V, E> original, Set<V> modulator) {
        Graph<V, DefaultEdge> undirected = new DefaultUndirectedGraph<>(DefaultEdge.class);

        // Add vertices (except modulator)
        original.vertexSet().stream().filter(v -> !modulator.contains(v)).forEach(undirected::addVertex);

        // Add edges
        original.edgeSet().parallelStream().forEach(edge -> {
            V source = original.getEdgeSource(edge);
            V target = original.getEdgeTarget(edge);

            if (undirected.containsVertex(source)
                    && undirected.containsVertex(target)
                    && !source.equals(target)
                    && !undirected.containsEdge(source, target)) {

                synchronized (undirected) {
                    if (!undirected.containsEdge(source, target)) {
                        undirected.addEdge(source, target);
                    }
                }
            }
        });

        return undirected;
    }

    /**
     * Minimum degree elimination ordering heuristic
     */
    private int minDegreeEliminationTreewidth(Graph<V, DefaultEdge> graph) {
        Set<V> remainingVertices =
                new ConcurrentHashMap<>(graph.vertexSet().stream().collect(Collectors.toMap(v -> v, v -> v))).keySet();

        Map<V, Set<V>> adjacencyMap = new ConcurrentHashMap<>();

        // Initialize adjacency map
        graph.vertexSet().parallelStream().forEach(v -> {
            adjacencyMap.put(v, ConcurrentHashMap.newKeySet());
            adjacencyMap.get(v).addAll(Graphs.neighborSetOf(graph, v));
        });

        int maxBagSize = 0;

        while (!remainingVertices.isEmpty()) {
            // Find vertex with minimum degree
            V minDegreeVertex = remainingVertices.parallelStream()
                    .min(Comparator.comparingInt(v -> (int) adjacencyMap.get(v).stream()
                            .filter(remainingVertices::contains)
                            .count()))
                    .orElse(null);

            if (minDegreeVertex == null) break;

            Set<V> neighbors = adjacencyMap.get(minDegreeVertex).stream()
                    .filter(remainingVertices::contains)
                    .collect(Collectors.toSet());

            maxBagSize = Math.max(maxBagSize, neighbors.size());

            // Make neighbors a clique
            neighbors.parallelStream().forEach(u -> {
                neighbors.parallelStream().filter(v -> !v.equals(u)).forEach(v -> {
                    adjacencyMap.get(u).add(v);
                    adjacencyMap.get(v).add(u);
                });
            });

            remainingVertices.remove(minDegreeVertex);
        }

        return maxBagSize;
    }

    /**
     * Fill-in heuristic for treewidth approximation
     */
    private int fillInHeuristicTreewidth(Graph<V, DefaultEdge> graph) {
        List<V> vertices = new ArrayList<>(graph.vertexSet());
        Map<V, Set<V>> adjacencyMap = new ConcurrentHashMap<>();

        // Initialize adjacency map
        vertices.parallelStream().forEach(v -> {
            adjacencyMap.put(v, ConcurrentHashMap.newKeySet());
            adjacencyMap.get(v).addAll(Graphs.neighborSetOf(graph, v));
        });

        int maxBagSize = 0;
        Set<V> processed = ConcurrentHashMap.newKeySet();

        for (V vertex : vertices) {
            if (processed.contains(vertex)) continue;

            Set<V> neighbors = adjacencyMap.get(vertex).stream()
                    .filter(v -> !processed.contains(v))
                    .collect(Collectors.toSet());

            maxBagSize = Math.max(maxBagSize, neighbors.size());

            // Calculate fill-in for this vertex
            int fillIn = calculateFillIn(neighbors, adjacencyMap);

            // Make neighbors a clique (simulate elimination)
            neighbors.parallelStream().forEach(u -> {
                neighbors.parallelStream().filter(v -> !v.equals(u)).forEach(v -> {
                    adjacencyMap.get(u).add(v);
                    adjacencyMap.get(v).add(u);
                });
            });

            processed.add(vertex);
        }

        return maxBagSize;
    }

    /**
     * Maximum clique based treewidth lower bound
     */
    private int maxCliqueTreewidth(Graph<V, DefaultEdge> graph) {
        if (graph.vertexSet().size() <= 50) {
            return findMaxCliqueBronKerbosch(graph) - 1;
        } else {
            return findMaxCliqueGreedy(graph) - 1;
        }
    }

    /**
     * Greedy triangulation heuristic
     */
    private int greedyTriangulationTreewidth(Graph<V, DefaultEdge> graph) {
        Map<V, Set<V>> adjacencyMap = new ConcurrentHashMap<>();

        // Initialize adjacency map
        graph.vertexSet().parallelStream().forEach(v -> {
            adjacencyMap.put(v, ConcurrentHashMap.newKeySet());
            adjacencyMap.get(v).addAll(Graphs.neighborSetOf(graph, v));
        });

        int maxBagSize = 0;
        Queue<V> eliminationOrder = new ConcurrentLinkedQueue<>(graph.vertexSet());

        while (!eliminationOrder.isEmpty()) {
            V vertex = eliminationOrder.poll();
            if (vertex == null) break;

            Set<V> neighbors = adjacencyMap.get(vertex);
            maxBagSize = Math.max(maxBagSize, neighbors.size());

            // Triangulate neighborhood
            triangulateNeighborhood(neighbors, adjacencyMap);
        }

        return maxBagSize;
    }

    private void triangulateNeighborhood(Set<V> neighbors, Map<V, Set<V>> adjacencyMap) {
        List<V> neighborList = new ArrayList<>(neighbors);
        neighborList.parallelStream().forEach(u -> {
            neighborList.parallelStream()
                    .filter(v -> !v.equals(u) && !adjacencyMap.get(u).contains(v))
                    .forEach(v -> {
                        adjacencyMap.get(u).add(v);
                        adjacencyMap.get(v).add(u);
                    });
        });
    }

    private int calculateFillIn(Set<V> neighbors, Map<V, Set<V>> adjacencyMap) {
        AtomicInteger fillIn = new AtomicInteger(0);

        neighbors.parallelStream().forEach(u -> {
            neighbors.parallelStream()
                    .filter(v -> !v.equals(u) && !adjacencyMap.get(u).contains(v))
                    .forEach(v -> fillIn.incrementAndGet());
        });

        return fillIn.get() / 2; // Each edge counted twice
    }

    private int findMaxCliqueBronKerbosch(Graph<V, DefaultEdge> graph) {
        Set<V> R = new HashSet<>();
        Set<V> P = new HashSet<>(graph.vertexSet());
        Set<V> X = new HashSet<>();
        AtomicInteger maxCliqueSize = new AtomicInteger(0);

        bronKerbosch(graph, R, P, X, maxCliqueSize);
        return maxCliqueSize.get();
    }

    private void bronKerbosch(Graph<V, DefaultEdge> graph, Set<V> R, Set<V> P, Set<V> X, AtomicInteger maxSize) {
        if (P.isEmpty() && X.isEmpty()) {
            maxSize.set(Math.max(maxSize.get(), R.size()));
            return;
        }

        for (V vertex : new HashSet<>(P)) {
            Set<V> neighbors = Graphs.neighborSetOf(graph, vertex);

            Set<V> newR = new HashSet<>(R);
            newR.add(vertex);

            Set<V> newP = new HashSet<>(P);
            newP.retainAll(neighbors);

            Set<V> newX = new HashSet<>(X);
            newX.retainAll(neighbors);

            bronKerbosch(graph, newR, newP, newX, maxSize);

            P.remove(vertex);
            X.add(vertex);
        }
    }

    private int findMaxCliqueGreedy(Graph<V, DefaultEdge> graph) {
        return graph.vertexSet().parallelStream()
                .mapToInt(v -> Graphs.neighborSetOf(graph, v).size() + 1)
                .max()
                .orElse(1);
    }

    private int computeFallbackTreewidth(Graph<V, DefaultEdge> graph) {
        // Simple fallback: maximum degree
        return graph.vertexSet().parallelStream()
                .mapToInt(v -> graph.degreeOf(v))
                .max()
                .orElse(0);
    }

    private Integer getFutureValue(Future<Integer> future) {
        try {
            return future.get();
        } catch (Exception e) {
            return null;
        }
    }

    public void shutdown() {
        if (executorService != null && !executorService.isShutdown()) {
            executorService.shutdown();
        }
    }
}
