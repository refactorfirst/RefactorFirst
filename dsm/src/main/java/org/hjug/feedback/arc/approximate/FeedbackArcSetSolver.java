package org.hjug.feedback.arc.approximate;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import org.jgrapht.Graph;

/**
 * Parallel implementation of Algorithm GR for the Feedback Arc Set problem
 * Based on Eades, Lin, and Smyth's fast and effective heuristic
 * DOI: https://doi.org/10.1016/0020-0190(93)90079-O
 * https://researchportal.murdoch.edu.au/esploro/outputs/journalArticle/A-fast-and-effective-heuristic-for/991005543112107891
 * Generated by Perplexity.ai's Research model
 */
public class FeedbackArcSetSolver<V, E> {

    private final Graph<V, E> graph;
    private final ConcurrentHashMap<V, AtomicInteger> inDegreeMap;
    private final ConcurrentHashMap<V, AtomicInteger> outDegreeMap;
    private final ConcurrentHashMap<Integer, CopyOnWriteArrayList<V>> vertexBins;

    public FeedbackArcSetSolver(Graph<V, E> graph) {
        this.graph = graph;
        this.inDegreeMap = new ConcurrentHashMap<>();
        this.outDegreeMap = new ConcurrentHashMap<>();
        this.vertexBins = new ConcurrentHashMap<>();
        initializeDegrees();
    }

    /**
     * Initialize degree maps using parallel streams for better performance
     */
    private void initializeDegrees() {
        graph.vertexSet().parallelStream().forEach(vertex -> {
            int inDegree = graph.inDegreeOf(vertex);
            int outDegree = graph.outDegreeOf(vertex);

            inDegreeMap.put(vertex, new AtomicInteger(inDegree));
            outDegreeMap.put(vertex, new AtomicInteger(outDegree));

            // Calculate delta value for bin sorting
            int delta = outDegree - inDegree;
            vertexBins.computeIfAbsent(delta, k -> new CopyOnWriteArrayList<>()).add(vertex);
        });
    }

    /**
     * Executes Algorithm GR to find a feedback arc set
     * @return FeedbackArcSetResult containing the vertex sequence and feedback arcs
     */
    public FeedbackArcSetResult<V, E> solve() {
        List<V> s1 = new CopyOnWriteArrayList<>();  // Left sequence
        List<V> s2 = new CopyOnWriteArrayList<>();  // Right sequence
        Set<V> remainingVertices = ConcurrentHashMap.newKeySet();
        remainingVertices.addAll(graph.vertexSet());

        Set<E> feedbackArcs = ConcurrentHashMap.newKeySet();

        while (!remainingVertices.isEmpty()) {
            // Process sinks in parallel
            List<V> sinks = findSinks(remainingVertices);
            sinks.parallelStream().forEach(sink -> {
                s2.add(0, sink);
                removeVertex(sink, remainingVertices, feedbackArcs);
            });

            if (remainingVertices.isEmpty()) break;

            // Process sources in parallel
            List<V> sources = findSources(remainingVertices);
            sources.parallelStream().forEach(source -> {
                s1.add(source);
                removeVertex(source, remainingVertices, feedbackArcs);
            });

            if (remainingVertices.isEmpty()) break;

            // Find vertex with maximum delta value
            Optional<V> maxDeltaVertex = findMaxDeltaVertex(remainingVertices);
            if (maxDeltaVertex.isPresent()) {
                V vertex = maxDeltaVertex.get();
                s1.add(vertex);
                removeVertex(vertex, remainingVertices, feedbackArcs);
            }
        }

        // Combine sequences
        List<V> finalSequence = new ArrayList<>(s1);
        finalSequence.addAll(s2);

        // Calculate feedback arcs based on final sequence
        Set<E> finalFeedbackArcs = calculateFeedbackArcs(finalSequence);

        return new FeedbackArcSetResult<>(finalSequence, finalFeedbackArcs);
    }

    /**
     * Find all sink vertices (vertices with out-degree 0) using parallel processing
     */
    private List<V> findSinks(Set<V> vertices) {
        return vertices.parallelStream()
                .filter(v -> outDegreeMap.get(v).get() == 0)
                .collect(Collectors.toList());
    }

    /**
     * Find all source vertices (vertices with in-degree 0) using parallel processing
     */
    private List<V> findSources(Set<V> vertices) {
        return vertices.parallelStream()
                .filter(v -> inDegreeMap.get(v).get() == 0)
                .collect(Collectors.toList());
    }

    /**
     * Find vertex with maximum delta value (out-degree - in-degree)
     */
    private Optional<V> findMaxDeltaVertex(Set<V> vertices) {
        return vertices.parallelStream()
                .max(Comparator.comparingInt(v ->
                        outDegreeMap.get(v).get() - inDegreeMap.get(v).get()));
    }

    /**
     * Remove vertex and update degrees of adjacent vertices
     */
    private void removeVertex(V vertex, Set<V> remainingVertices, Set<E> feedbackArcs) {
        remainingVertices.remove(vertex);

        // Update degrees of adjacent vertices in parallel
        graph.incomingEdgesOf(vertex).parallelStream().forEach(edge -> {
            V source = graph.getEdgeSource(edge);
            if (remainingVertices.contains(source)) {
                outDegreeMap.get(source).decrementAndGet();
            }
        });

        graph.outgoingEdgesOf(vertex).parallelStream().forEach(edge -> {
            V target = graph.getEdgeTarget(edge);
            if (remainingVertices.contains(target)) {
                inDegreeMap.get(target).decrementAndGet();
            }
        });
    }

    /**
     * Calculate feedback arcs based on the final vertex sequence
     */
    private Set<E> calculateFeedbackArcs(List<V> sequence) {
        Map<V, Integer> vertexPosition = new HashMap<>();
        for (int i = 0; i < sequence.size(); i++) {
            vertexPosition.put(sequence.get(i), i);
        }

        return graph.edgeSet().parallelStream()
                .filter(edge -> {
                    V source = graph.getEdgeSource(edge);
                    V target = graph.getEdgeTarget(edge);
                    return vertexPosition.get(source) > vertexPosition.get(target);
                })
                .collect(Collectors.toSet());
    }
}
